<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome!</title>
    <url>/2024/06/30/hello-world/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>欢迎访问我的博客！
这些是我的在工作和学习中学到的一些知识，希望能帮到你</p>
</blockquote>
<hr>
<p>More info: <a href="https://www.instagram.com/yyx0607?igsh=MXN0MGYzY3c5ZjMwNw==&utm_source=qr">My Instagram</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用Spring Security 实现（SpringBoot+Vue3.0）项目的登录功能</title>
    <url>/2024/06/30/Spring-Security-%E6%90%AD%E5%BB%BA-1/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>这篇文章会讲述如何将Spring Security导入（SpringBoot+Vue3.0）项目</p>
<p>假设目前我们已经搭建好了一个<code>SpringBoot+Vue3.0</code>项目，那么当我们需要实现登录功能时，可以使用<strong>Spring Security</strong>来快速搭建</p>
<hr>
<h5 id="注入依赖"><a href="#注入依赖" class="headerlink" title="注入依赖"></a>注入依赖</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Spring Security</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="配置SecurityConfig-class文件-Config文件位置"><a href="#配置SecurityConfig-class文件-Config文件位置" class="headerlink" title="配置SecurityConfig.class文件(Config文件位置)"></a>配置SecurityConfig.class文件(Config文件位置)</h5><p><a href="https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/index.html">配置SecurityConfig.class文件参考链接</a></p>
<p>这个文件会被<strong>自动</strong>调用，里面的method全部显示灰色也是正常的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.HttpStatusEntryPoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt;</span><br><span class="line">                        authorize</span><br><span class="line">                                .requestMatchers(<span class="string">&quot;/example/*&quot;</span>).authenticated()<span class="comment">//未认证身份不得进入的url</span></span><br><span class="line">                                .anyRequest().permitAll()</span><br><span class="line">                )</span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .formLogin(formLogin -&gt;</span><br><span class="line">                        formLogin.loginPage(<span class="string">&quot;/login&quot;</span>)<span class="comment">//login界面可以是自己定义的页面，这里我用的前端时Vue，在前端调用了后端的localhost:8080/login（Spring Security自动也会有一个默认login页面）</span></span><br><span class="line">                                .usernameParameter(<span class="string">&quot;email&quot;</span>)<span class="comment">//前端传来的认证名字or邮箱，用来在数据库中查找整个用户信息</span></span><br><span class="line">                                .passwordParameter(<span class="string">&quot;password&quot;</span>)<span class="comment">//接收前端传来的密码</span></span><br><span class="line">                                <span class="comment">//成功ハンドラー</span></span><br><span class="line">                                .successHandler((request, response, authentication) -&gt; response.setStatus(HttpStatus.OK.value()))</span><br><span class="line">                                <span class="comment">//失敗ハンドラー</span></span><br><span class="line">                                .failureHandler((request, response, exception) -&gt; response.setStatus(HttpStatus.UNAUTHORIZED.value()))</span><br><span class="line">                ).logout(logout -&gt; logout.logoutSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">                    response.setStatus(HttpStatus.OK.value());</span><br><span class="line">                &#125;)).exceptionHandling().authenticationEntryPoint((<span class="keyword">new</span> <span class="title class_">HttpStatusEntryPoint</span>(HttpStatus.UNAUTHORIZED)));</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Cors配置，允许Vue的5173端口的一切访问</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                        .allowedOrigins(<span class="string">&quot;http://localhost:5173&quot;</span>)</span><br><span class="line">                        .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                        .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                        .allowCredentials(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Beanとして登録しておけば自動的にこのEncoderが使われる</span></span><br><span class="line">    <span class="comment">//自动密码加密</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        PasswordEncoder bCryptPasswordEncoder=<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">        System.out.println(bCryptPasswordEncoder.encode(<span class="string">&quot;1234&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> bCryptPasswordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置UserModel"><a href="#配置UserModel" class="headerlink" title="配置UserModel"></a>配置UserModel</h5><p>我使用了<code>UserEntity</code>来存储User信息，同时为了实现Security的自动调用，</p>
<p>需要建一个<code>AuthenticatedUserEntitys.class</code> 来继承Security提供的接口<code> UserDetail</code></p>
<p>UserEntity.class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String userEmail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String hashedPassword;<span class="comment">//因为要存储从数据库取来的密码，所以是已加密的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEntity</span><span class="params">(Integer userId, String username, String userEmail, String encodedPassword)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">        <span class="built_in">this</span>.userName = username;</span><br><span class="line">        <span class="built_in">this</span>.userEmail = userEmail;</span><br><span class="line">        <span class="built_in">this</span>.hashedPassword = encodedPassword;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AuthenticatedUserEntitys.class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="comment">//UserDetails的子类在登录时会被一一调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticatedUserEntity</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//导入我们自己写的UserEntity</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserEntity userEntity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//识别身份信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取用于比对的密码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userEntity.getHashedPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取用于登录的用户名（此处我用的是email）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userEntity.getUserEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userEntity.getUserId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="配置AuthUserFetchService-用于继承实现接口"><a href="#配置AuthUserFetchService-用于继承实现接口" class="headerlink" title="配置AuthUserFetchService(用于继承实现接口)"></a>配置AuthUserFetchService(用于继承实现接口)</h5><p><code>AuthUserFetchService.class</code>继承<code>UserDetailsService</code>来实现登录时的自动调用，在这个类里我们要实现对数据库的访问和保存用户信息</p>
<p>AuthUserFetchService:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 認証用のユーザ取得サービス</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthUserFetchService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="comment">// Bean(=Component)として登録しておけば自動的にこのUserDetailsServiceが使われる</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String email)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;load user: &#123;&#125;&quot;</span>, email);<span class="comment">//日志，调试用</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.fetchByEmail(email)<span class="comment">//调用对数据库的访问，这里就不详细写了(userRepository-&gt;userMapper-&gt;查询User的全部信息，不只是email和密码，这个类不是用来直接比对的，比对操作是在继承了UserDetail的类里完成，不用手写)</span></span><br><span class="line">                .map(AuthenticatedUserEntity::<span class="keyword">new</span>)<span class="comment">//可能有复数个，所以用map保存</span></span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;user is not found&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们的后端就已经完成了，可以使用localhost:8080&#x2F;login尝试登录，在开发者模式的application里查看cookie情况确认</p>
<p>注意：当我们确认的时候，一定要在同一个页面来登录和执行后续操作。请不要在页面中登录但是却在postman测试结果，他们并不共享session</p>
<h5 id="在前端已开发的login-vue文件里调用login功能"><a href="#在前端已开发的login-vue文件里调用login功能" class="headerlink" title="在前端已开发的login.vue文件里调用login功能"></a>在前端已开发的login.vue文件里调用login功能</h5><p>注意调用api时保证参数名是<code>email</code>和<code>password</code>，让后端能正确识别</p>
<blockquote>
<p>script写法：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义变量，接收input中的值</span></span><br><span class="line"><span class="keyword">const</span> email = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> password = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">//async实现异步调用login</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//axios实现网络请求访问后端</span></span><br><span class="line">  axios.<span class="title function_">postForm</span>(<span class="string">&#x27;http://localhost:8080/login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">email</span>: email.<span class="property">value</span>,</span><br><span class="line">    <span class="attr">password</span>: password.<span class="property">value</span></span><br><span class="line">  &#125;, &#123; <span class="attr">withCredentials</span>: <span class="literal">true</span> &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//登录成功则重定向到首页&#x27;/&#x27;</span></span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;There was an error!&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>完成以上操作就可以实现login登录功能了</p>
<h5 id="登录情况和登录用户信息的确认"><a href="#登录情况和登录用户信息的确认" class="headerlink" title="登录情况和登录用户信息的确认"></a>登录情况和登录用户信息的确认</h5><p>可以编写方法来在后端确认登录情况(port:8080)</p>
<p>同时也可以在前端(如果是Vue)进行用户信息的获取(port:5173)</p>
<p>接下来我把前端和后端分开记录</p>
<h6 id="后端-backend———-port-8080"><a href="#后端-backend———-port-8080" class="headerlink" title="后端&#x2F;backend———-(port:8080)"></a>后端&#x2F;backend———-(port:8080)</h6><p>先写后端的原因是前端需要调用后端的api</p>
<p>首先我们需要写一个认证类<code>AuthorizationUserAccessor.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx.AuthenticatedUserEntity;</span><br><span class="line"><span class="keyword">import</span> xxx.UserEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AnonymousAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationUserAccessor</span> &#123;</span><br><span class="line">		<span class="comment">//后端可以通过调用这个方法，来获取有关User的信息，返回UserEntity</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;UserEntity&gt; <span class="title function_">getUserEntity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">if</span> (!authentication.isAuthenticated() || authentication <span class="keyword">instanceof</span> AnonymousAuthenticationToken) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.of((AuthenticatedUserEntity) authentication.getPrincipal()).map(AuthenticatedUserEntity::getUserEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们使用openApi，那么controller代码如下(也可以使用@GetMapping)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这是用来获取登录email和登录状态的api</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ResponseEntity&lt;UserModel&gt; <span class="title function_">usersMeGet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用AuthorizationUserAccessor.getUserEntity()来获取用户数据</span></span><br><span class="line">      <span class="type">var</span> <span class="variable">userEntityOptional</span> <span class="operator">=</span> AuthorizationUserAccessor.getUserEntity();</span><br><span class="line">      <span class="comment">//可能有数个用户，所以是Optional</span></span><br><span class="line">      <span class="comment">//如果存在已登录用户，则返回email的值(也可能是别的值，比如userId)</span></span><br><span class="line">      <span class="type">var</span> <span class="variable">responseModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserModel</span>(userEntityOptional.isPresent())</span><br><span class="line">              .userEmail(userEntityOptional.map(UserEntity::getUserEmail).orElse(<span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(responseModel, HttpStatus.OK);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们希望在后端的其他方法中获取user信息(比如ID)，可以用这句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">loginUserId</span> <span class="operator">=</span> AuthorizationUserAccessor.getUserEntity().map(UserEntity::getUserId)</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UnauthorizedException</span>(<span class="string">&quot;unauthorized&quot;</span>));</span><br></pre></td></tr></table></figure>

<h6 id="前端-frontend———-port-5173"><a href="#前端-frontend———-port-5173" class="headerlink" title="前端&#x2F;frontend———-(port:5173)"></a>前端&#x2F;frontend———-(port:5173)</h6><p><img src="/images/pasted-0.png" alt="前端文件构造"></p>
<p>首先在上图位置创建一个<code>auth-user.ts</code>文件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; userApi &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/job-api-accessor&#x27;</span><span class="comment">//导入上述后端获取用户信息的api</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">ANONYMOUS</span>, <span class="keyword">type</span> <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/domain/user&#x27;</span><span class="comment">//导入数据类型</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, <span class="keyword">type</span> <span class="title class_">Ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ユーザ情報を取得する</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> ユーザ情報</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useUser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">Ref</span>&lt;<span class="title class_">User</span>&gt; = <span class="title function_">ref</span>(<span class="variable constant_">ANONYMOUS</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//异步调用获取用户信息api</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getUser</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> userApi.<span class="title function_">usersMeGet</span>()</span><br><span class="line">    user.<span class="property">value</span> = &#123; ...response.<span class="property">data</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//返回的值，user包括了user_email和认证状态，getUser是执行api的Promise方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123; user, getUser &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时为了方便控制user的数据类型，我们需要创建一个<code>domian/user.ts</code>文件来整合数据类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未初始化数据类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  user_email?: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">is_authenticated</span>: <span class="built_in">boolean</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已初始化测试用数据类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">LOGIN_TEST_USER</span> = &#123;</span><br><span class="line">  <span class="attr">user_email</span>: <span class="string">&#x27;dummy_user&#x27;</span>,</span><br><span class="line">  <span class="attr">is_authenticated</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已初始化数据类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ANONYMOUS</span> = &#123;</span><br><span class="line">  <span class="attr">user_email</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">is_authenticated</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在其他ts文件中的调用方法(获取当前用户信息):</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.导入auth-user</span></span><br><span class="line"><span class="keyword">import</span> &#123; useUser &#125; <span class="keyword">from</span> <span class="string">&#x27;@/composable/auth-user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.初始化auth-user中的user和getUser</span></span><br><span class="line"><span class="keyword">const</span> &#123; user, getUser &#125; = <span class="title function_">useUser</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在监听函数中调用getUser来获取当前用户信息</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">getUser</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.此时就可以通过user.user_email和user.is_authenticated(自己起的数据类型名)来获取相应的目前登录用户的信息了,比如:</span></span><br><span class="line"><span class="keyword">if</span> (user.<span class="property">is_authenticated</span> ) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;user_email:&#x27;</span>, user.<span class="property">user_email</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work_kenshu</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>Spring Security</tag>
        <tag>Vue3</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
